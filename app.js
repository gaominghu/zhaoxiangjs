// Generated by CoffeeScript 1.9.0
(function() {
  var app, camera, gphoto, id, logRequests, name, preview_listeners, requests, _ref;
  var io = require('socket.io-client');
  var ioserver = io.connect('http://ux31e.local:3001');
  ioserver.on('connect', function () {
    console.log("socketio connected");
  });
  var lastPicture;


  process.title = 'node-gphoto2 test program';

  _ref = {
    "fs": "fs",
    "GPhoto": "gphoto2",
    "express": "express",
    _: "underscore",
    "bodyParser": "body-parser"

  };
  for (id in _ref) {
    name = _ref[id];
    if (global[id] == null) {
      global[id] = require(name);
    }
  }

  gphoto = new GPhoto.GPhoto2();

  requests = {};

  preview_listeners = [];

  camera = void 0;

  gphoto.list(function(cameras) {
    console.log("found " + cameras.length + " cameras");
    camera = _(cameras).chain().filter(function(camera) {
      return camera.model.match(/(Canon|Nikon)/);
    }).first().value();
    if (!camera) {
      process.exit(-1);
    }
    console.log("loading " + camera.model + " settings");
    return camera.getConfig(function(er, settings) {
      if (er) {
        console.error({
          camera_error: er
        });
      }
      return console.log(settings);
    });
  });

  app = express();

  app.use(express["static"](__dirname + '/public'));

  //app.use(express.bodyParser());
  app.use(bodyParser.urlencoded({ extended: false }));
  app.use(bodyParser.json());

  app.engine('.html', require('jade').__express);

  app.get('/', function(req, res) {
    return res.render('index.html');
  });

  logRequests = function() {
    var d, fps;
    d = Date.parse(new Date()) / 1000;
    if (requests[d] > 0) {
      return requests[d]++;
    } else {
      fps = requests[d - 1];
      requests = {};
      requests[d] = 1;
      if (fps) {
        return console.log(fps + " fps");
      }
    }
  };

  app.put('/settings/:name', function(req, res) {
    if (!camera) {
      return res.send(404, 'Camera not connected');
    } else {
      return camera.setConfigValue(req.params.name, req.body.newValue, function(er) {
        if (er) {
          return res.send(404, JSON.stringify(er));
        } else {
          return res.send(200);
        }
      });
    }
  });

  app.get('/settings', function(req, res) {
    if (!camera) {
      return res.send(404, 'Camera not connected');
    } else {
      return camera.getConfig(function(er, settings) {
        return res.send(JSON.stringify(settings));
      });
    }
  });

  app.get('/download/*', function(req, res) {
    var match, path;
    if (!camera) {
      return res.send(404, 'Camera not connected');
    } else {
      if ((match = req.url.match(/download(.*)$/)) && (path = match[1])) {
        console.log("trying to DL " + path);
        /*
        return camera.downloadPicture({
          cameraPath: path
        }, function(er, data) {
          if (er) {
            return res.send(404, er);
          } else {
            res.header('Content-Type', 'image/jpeg');
            return res.send(data);
          }
        });
        */
        return fs.readFile(path, function (er, data) {
          if (er) {
            return res.send(404, er);
          } else {
            res.header('Content-Type', 'image/jpeg');
            return res.send(data);
          }
        });
      }
    }
  });
  app.get('/lastPicture', function(req, res) {
            res.header('Content-Type', 'image/jpeg');
            console.log('lastPicture: ' + lastPicture);
            return res.send("/download" + lastPicture);
  });

  app.get('/takePicture', function(req, res) {
    if (!camera) {
      return res.send(404, 'Camera not connected');
    } else {
      return camera.takePicture({
        download: (req.query.download === 'false' ? false : true),
        //download: true,
        targetPath: '/tmp/foo.XXXXXXX'
      }, function(er, data) {
        if (er) {
          console.log(er);
          return res.send(404, er);
        } else {
          if (req.query.download === 'false') {
            lastPicture =  data;
            console.log('lastPicture: ' + lastPicture);
            return res.send("/download" + lastPicture);
          } else {
            res.header('Content-Type', 'image/jpeg');
            lastPicture =  data;
            console.log('lastPicture: ' + lastPicture);
            return res.send("/download" + lastPicture);
            //return res.send(data);
            //return res.send("/download" + data);
          }
        }
      });
    }
  });

  ioserver.on('shoot', function() {
    if (!camera) {
      // TODO: socketio error retrieve
      console.log(er);
    } else {
      return camera.takePicture({
        download: true,
        targetPath: '/tmp/foo.XXXXXXX'
      }, function(er, data) {
        if (er) {
          console.log(er);
          // TODO: socketio error retrieve
        } else {
            lastPicture =  data;
            console.log('lastPicture: ' + lastPicture);
        }
      });
    }
  });


  app.get('/preview*', function(req, res) {
    if (!camera) {
      return res.send(404, 'Camera not connected');
    } else {
      preview_listeners.push(res);
      if (preview_listeners.length === 1) {
        return camera.takePicture({
          preview: true
        }, function(er, data) {
          var d, listener, tmp, _i, _len, _results;
          logRequests();
          tmp = preview_listeners;
          preview_listeners = new Array();
          d = Date.parse(new Date());
          _results = [];
          for (_i = 0, _len = tmp.length; _i < _len; _i++) {
            listener = tmp[_i];
            if (!er) {
              listener.writeHead(200, {
                'Content-Type': 'image/jpeg',
                'Content-Length': data.length
              });
              listener.write(data);
            } else {
              listener.writeHead(500);
            }
            _results.push(listener.end());
          }
          return _results;
        });
      }
    }
  });

  app.listen(process.env.PORT || 1337, "0.0.0.0");

}).call(this);
